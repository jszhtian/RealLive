#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include <windows.h>



typedef unsigned char byte;
typedef unsigned short word;
unsigned char* buf;
typedef unsigned int ulong;

//0x4C //头大小,下面是数据..
//0x50 文件数量
//0x44 file_offset_info_s

typedef struct FILE_INFO{
	DWORD offset;
	DWORD length;
} FILE_INFO,*PFILE_INFO;

typedef struct HEADERPAIR{
	int offset;
	int count;
}HEADERPAIR;

typedef struct ss_header{
	DWORD szZiped;
	DWORD szOrigianl;
}ss_header;

typedef struct SCENEHEADER{
	int headerLength;
	HEADERPAIR varInfo;
	HEADERPAIR varNameIndex;
	HEADERPAIR varName;
	HEADERPAIR cmdInfo;
	HEADERPAIR cmdNameIndex;
	HEADERPAIR cmdName;
	HEADERPAIR SceneNameIndex;
	HEADERPAIR SceneName;
	HEADERPAIR SceneInfo;
	HEADERPAIR SceneData;
	int ExtraKeyUse;
	int SourceHeaderLength;
}SCENEHEADER;
typedef struct file_offset_info_s
{
	ulong offsets;
	ulong sizes;
}file_offset_info_t;


typedef struct compress_file_header_s
{
	ulong comp_size;
	ulong decomp_size;
}compress_file_header_t;


void decrypt_1(byte* debuf,size_t desize)
{
	size_t key_idx = 0;
	size_t xor_idx = 0;
	static byte key[] = 
	{
		0x5F,0x07,0x8A,0x2A,0x66,0xA7,0x11,0xA6,0x84,0x6D,0x9D,0x46,0x9F,0x7A,0xB9,0x7E,0x29,0x84,0xB8,0xDF,0x79,0xF1,0x4E,0x00,0xD4,0xE8,0x18,0x00,0xAC,0xC4,0x92,0x00
	};

	for(xor_idx = 0;xor_idx<desize;xor_idx++,key_idx++,key_idx = key_idx & 0x8000000F)
	{
		debuf[xor_idx] ^= key[key_idx];
	}
}

void decrypt_2(byte* debuf,size_t desize)
{
	size_t key_idx = 0;
	size_t xor_idx = 0;

	static byte key[] = 
	{
		0xD8,0x29,0xB9,0x16,0x3D,0x1A,0x76,0xD0,0x87,0x9B,0x2D,0x0C,0x7B,0xD1,0xA9,0x19,0x22,0x9F,0x91,0x73,0x6A,0x35,0xB1,0x7E,0xD1,0xB5,0xE7,0xE6,0xD5,0xF5,0x06,0xD6,
		0xBA,0xBF,0xF3,0x45,0x3F,0xF1,0x61,0xDD,0x4C,0x67,0x6A,0x6F,0x74,0xEC,0x7A,0x6F,0x26,0x74,0x0E,0xDB,0x27,0x4C,0xA5,0xF1,0x0E,0x2D,0x70,0xC4,0x40,0x5D,0x4F,0xDA,
		0x9E,0xC5,0x49,0x7B,0xBD,0xE8,0xDF,0xEE,0xCA,0xF4,0x92,0xDE,0xE4,0x76,0x10,0xDD,0x2A,0x52,0xDC,0x73,0x4E,0x54,0x8C,0x30,0x3D,0x9A,0xB2,0x9B,0xB8,0x93,0x29,0x55,
		0xFA,0x7A,0xC9,0xDA,0x10,0x97,0xE5,0xB6,0x23,0x02,0xDD,0x38,0x4C,0x9B,0x1F,0x9A,0xD5,0x49,0xE9,0x34,0x0F,0x28,0x2D,0x1B,0x52,0x39,0x5C,0x36,0x89,0x56,0xA7,0x96,
		0x14,0xBE,0x2E,0xC5,0x3E,0x08,0x5F,0x47,0xA9,0xDF,0x88,0x9F,0xD4,0xCC,0x69,0x1F,0x30,0x9F,0xE7,0xCD,0x80,0x45,0xF3,0xE7,0x2A,0x1D,0x16,0xB2,0xF1,0x54,0xC8,0x6C,
		0x2B,0x0D,0xD4,0x65,0xF7,0xE3,0x36,0xD4,0xA5,0x3B,0xD1,0x79,0x4C,0x54,0xF0,0x2A,0xB4,0xB2,0x56,0x45,0x2E,0xAB,0x7B,0x88,0xC5,0xFA,0x74,0xAD,0x03,0xB8,0x9E,0xD5,
		0xF5,0x6F,0xDC,0xFA,0x44,0x49,0x31,0xF6,0x83,0x32,0xFF,0xC2,0xB1,0xE9,0xE1,0x98,0x3D,0x6F,0x31,0x0D,0xAC,0xB1,0x08,0x83,0x9D,0x0D,0x10,0xD1,0x41,0xF9,0x00,0xBA,
		0x1A,0xCF,0x13,0x71,0xE4,0x86,0x21,0x2F,0x23,0x65,0xC3,0x45,0xA0,0xC3,0x92,0x48,0x9D,0xEA,0xDD,0x31,0x2C,0xE9,0xE2,0x10,0x22,0xAA,0xE1,0xAD,0x2C,0xC4,0x2D,0x7F,
		0x70,0xF8,0xA6,0xB0,0xA1,0xA5,0x28,0x4F,0xB5,0x2F,0x48,0xFA,0xE1,0xE9,0x4B,0xDE,0xB7,0x4F,0x62,0x95,0x8B,0xE0,0x03,0x80,0xE7,0xCF,0x0F,0x6B,0x92,0x01,0xEB,0xF8,
		0xA2,0x88,0xCE,0x63,0x04,0x38,0xD2,0x6D,0x8C,0xD2,0x88,0x76,0xA7,0x92,0x71,0x8F,0x4E,0xB6,0x8D,0x01,0x79,0x88,0x83,0x0A,0xF9,0xE9,0x2C,0xDB,0x67,0xDB,0x91,0x14
	};
	for(xor_idx = 0;xor_idx<desize;xor_idx++,key_idx++,key_idx = key_idx & 0x800000FF)
	{
		debuf[xor_idx] ^= key[key_idx];
	}
}
void decompress_data(byte* comp_data,byte* decomp_begin,byte* decomp_end)
{
	byte* s = comp_data;
	byte* d = decomp_begin;
	byte c;
	while(true)
	{
		c = *s++;
		byte n=8;
		do
		{
			if(d == decomp_end)
			{
				return;
			}
			if(c & 0x1)
			{
				memcpy(d,s,sizeof(byte));
				s++;
				d++;
			}
			else
			{
				unsigned int o,f;

				o = (unsigned int)*(unsigned short*)s;

				s += sizeof(unsigned short);
				f = o;
				o >>= 4;
				f = (f & 0xF) + 0x2;

				memcpy(d,(void*)(d - o),f);
				d += f;
			}
			c >>= 1;
			n--;
		}while(n);
	}
}
//void decompress_data(byte* comp_data,byte* decomp_begin,byte* decomp_end)
//{
//	__asm
//	{
//		mov esi,comp_data
//		mov edi,decomp_begin
//		xor edx,edx
//		cld
//Loop1:
//		mov dl,byte ptr [esi]
//		inc esi
//		mov dh,0x8
//Loop2:
//		cmp edi,decomp_end
//		je End
//		test dl,1
//		je DecompTag
//		movsb
//		jmp DecompTag2
//DecompTag:
//		xor eax,eax
//		lods word ptr [esi]
//		mov ecx,eax
//		shr eax,4
//		and ecx,0xF
//		add ecx,0x2
//		mov ebx,esi
//		mov esi,edi
//		sub esi,eax
//		rep movsb
//		mov esi,ebx
//DecompTag2:
//		shr dl,1
//		dec dh
//		jnz Loop2
//		jmp Loop1
//
//End:
//	}
//}
int main(int argc,char** args)
{
	char* file_name;
	if(argc > 1)
	{
		file_name = args[1];
	}
	else
		return 0;
	FILE* f= fopen(file_name,"rb");
	fseek(f,0,SEEK_END);
	unsigned int size = ftell(f);
	fseek(f,0,SEEK_SET);
	buf = (unsigned char*)malloc(size);
	fread(buf,size,1,f);
	
	wchar_t usFileName[128];
	SCENEHEADER* header = (SCENEHEADER*)buf;
	HEADERPAIR* SceneNameLength = (HEADERPAIR*)&buf[header->SceneNameIndex.offset];
	wchar_t* SceneNameString = (wchar_t*)&buf[header->SceneName.offset];
	HEADERPAIR* SceneDataInfo = (HEADERPAIR*)&buf[header->SceneInfo.offset];
	byte* SceneData = (byte*)&buf[header->SceneData.offset];

	for(DWORD i=0;i<header->SceneNameIndex.count;i++)
	{
		compress_file_header_t compress_info;
		memset(&usFileName,0,sizeof(usFileName));
		wcsncpy(usFileName,&SceneNameString[SceneNameLength[i].offset],SceneNameLength[i].count);
		wchar_t ss[33];
		wsprintf(ss,L"_%d",i);
		wcscat(usFileName,ss);
		wcscat(usFileName,L".ss");
		byte* data = &SceneData[SceneDataInfo[i].offset];
		decrypt_1(data,SceneDataInfo[i].count);
		decrypt_2(data,SceneDataInfo[i].count);

		memcpy(&compress_info,data,sizeof(compress_file_header_t));

		byte* decompress_buf = (byte*)malloc(compress_info.decomp_size);
		byte* decompress_end = decompress_buf + compress_info.decomp_size;

		memset(decompress_buf,0,compress_info.decomp_size);

		memcpy(decompress_buf,data+8,compress_info.decomp_size);

		//decompress_data(data+8,decompress_buf,decompress_end);

		FILE* f2 = _wfopen(usFileName,L"wb");

		fwrite(decompress_buf,compress_info.decomp_size,1,f2);
		fclose(f2);

	}
	//getchar();



	return 0;
}