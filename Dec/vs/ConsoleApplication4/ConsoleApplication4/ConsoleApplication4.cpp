// ConsoleApplication4.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
typedef unsigned char byte;
typedef unsigned short word;
unsigned char* buf;
unsigned char* data;
typedef unsigned int ulong;


void decrypt_1(byte* debuf, size_t desize)
{
	size_t key_idx = 0;
	size_t xor_idx = 0;
	static byte key[] =
	{
		0xB9, 0x1D ,0x47 ,0xE6 ,0xBD ,0x0D ,0x09 ,0xBF ,0xE7 ,0xE8 ,0xFD ,0x7E ,0xAC ,0x17 ,0xFD ,0x3A
	};

	for (xor_idx = 0; xor_idx < desize; xor_idx++, key_idx++, key_idx = key_idx & 0x8000000F)
	{
		debuf[xor_idx] ^= key[key_idx];
	}
}

void decrypt_2(byte* debuf, size_t desize)
{
	size_t key_idx = 0;
	size_t xor_idx = 0;

	static byte key[] =
	{
		0xD8,0x29,0xB9,0x16,0x3D,0x1A,0x76,0xD0,0x87,0x9B,0x2D,0x0C,0x7B,0xD1,0xA9,0x19,0x22,0x9F,0x91,0x73,0x6A,0x35,0xB1,0x7E,0xD1,0xB5,0xE7,0xE6,0xD5,0xF5,0x06,0xD6,
		0xBA,0xBF,0xF3,0x45,0x3F,0xF1,0x61,0xDD,0x4C,0x67,0x6A,0x6F,0x74,0xEC,0x7A,0x6F,0x26,0x74,0x0E,0xDB,0x27,0x4C,0xA5,0xF1,0x0E,0x2D,0x70,0xC4,0x40,0x5D,0x4F,0xDA,
		0x9E,0xC5,0x49,0x7B,0xBD,0xE8,0xDF,0xEE,0xCA,0xF4,0x92,0xDE,0xE4,0x76,0x10,0xDD,0x2A,0x52,0xDC,0x73,0x4E,0x54,0x8C,0x30,0x3D,0x9A,0xB2,0x9B,0xB8,0x93,0x29,0x55,
		0xFA,0x7A,0xC9,0xDA,0x10,0x97,0xE5,0xB6,0x23,0x02,0xDD,0x38,0x4C,0x9B,0x1F,0x9A,0xD5,0x49,0xE9,0x34,0x0F,0x28,0x2D,0x1B,0x52,0x39,0x5C,0x36,0x89,0x56,0xA7,0x96,
		0x14,0xBE,0x2E,0xC5,0x3E,0x08,0x5F,0x47,0xA9,0xDF,0x88,0x9F,0xD4,0xCC,0x69,0x1F,0x30,0x9F,0xE7,0xCD,0x80,0x45,0xF3,0xE7,0x2A,0x1D,0x16,0xB2,0xF1,0x54,0xC8,0x6C,
		0x2B,0x0D,0xD4,0x65,0xF7,0xE3,0x36,0xD4,0xA5,0x3B,0xD1,0x79,0x4C,0x54,0xF0,0x2A,0xB4,0xB2,0x56,0x45,0x2E,0xAB,0x7B,0x88,0xC5,0xFA,0x74,0xAD,0x03,0xB8,0x9E,0xD5,
		0xF5,0x6F,0xDC,0xFA,0x44,0x49,0x31,0xF6,0x83,0x32,0xFF,0xC2,0xB1,0xE9,0xE1,0x98,0x3D,0x6F,0x31,0x0D,0xAC,0xB1,0x08,0x83,0x9D,0x0D,0x10,0xD1,0x41,0xF9,0x00,0xBA,
		0x1A,0xCF,0x13,0x71,0xE4,0x86,0x21,0x2F,0x23,0x65,0xC3,0x45,0xA0,0xC3,0x92,0x48,0x9D,0xEA,0xDD,0x31,0x2C,0xE9,0xE2,0x10,0x22,0xAA,0xE1,0xAD,0x2C,0xC4,0x2D,0x7F
	};
	for (xor_idx = 0; xor_idx < desize; xor_idx++, key_idx++, key_idx = key_idx & 0x800000FF)
	{
		debuf[xor_idx] ^= key[key_idx];
	}
}
void decompress_data(byte* comp_data, byte* decomp_begin, byte* decomp_end)
{
	__asm
	{
		mov esi, comp_data
		mov edi, decomp_begin
		xor edx, edx
		cld
		Loop1 :
		mov dl, byte ptr[esi]
			inc esi
			mov dh, 0x8
			Loop2 :
			cmp edi, decomp_end
			je End
			test dl, 1
			je DecompTag
			movsb
			jmp DecompTag2
			DecompTag :
		xor eax, eax
			lods word ptr[esi]
			mov ecx, eax
			shr eax, 4
			and ecx, 0xF
			add ecx, 0x2
			mov ebx, esi
			mov esi, edi
			sub esi, eax
			rep movsb
			mov esi, ebx
			DecompTag2 :
		shr dl, 1
			dec dh
			jnz Loop2
			jmp Loop1

			End :
	}
}

typedef struct SizePart {
	int size;
	int decompresssize;
}Sizepart;





int main(int argc, char** args)
{
	char* file_name;
	if (argc > 1)
	{
		file_name = args[1];
	}
	else
		return 0;
	FILE* f = fopen(file_name, "rb");
	fseek(f, 0, SEEK_END);
	unsigned int size = ftell(f);
	fseek(f, 0, SEEK_SET);
	//buf = (unsigned char*)malloc(size);
	//fread(buf, size, 1, f);
	fseek(f, 8, 0);
	data = (unsigned char*)malloc(size - 8);
	fread(data, size-8, 1, f);
	decrypt_1(data, size - 8);
	decrypt_2(data, size - 8);
	byte* buffdecom = (byte*)malloc(0xA8CE);
	byte* buffend = buffdecom + 0xA8CE;
	memset(buffdecom, 0, 0xA8CE);
	decompress_data(data + 8, buffdecom, buffend);

	FILE* f2 = _wfopen(L"output.txt", L"wb");
	fwrite(buffdecom, 0xA8CE, 1, f2);
	fclose(f2);





    return 0;
}

